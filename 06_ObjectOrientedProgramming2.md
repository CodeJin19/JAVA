# Object Oriented Programming2

## 목차

[JVM의 메모리 구조](#JVM의-메모리-구조)

[클래스 메서드와 인스턴스 메서드](#클래스-메서드와-인스턴스-메서드)

[오버로딩](#오버로딩)

[가변인자 오버로딩](#가변인자-오버로딩)

[생성자](#생성자)

[기본 생성자](#기본-생성자)

[초기화 블록](#초기화-블록)

<br>

## JVM의 메모리 구조

아래 표는 JVM 메모리 구조의 도식화다.

| JVM 메모리 구조 |
| --------------- |
| Method Area     |
| Call stack      |
| Heap            |

<br>

> 1. 메서드 영역
>    - 클래스가 사용될 때마다 JVM은 해당 클래스파일을 읽고 분석하여 클래스 데이터를 메서드 영역에 저장한다.
>    - 클래스 변수가 저장되는 공간
> 2. 힙 영역
>    - 인스턴스가 생성되는 공간
>    - 인스턴스 변수가 저장되는 공간
> 3. 호출 스택
>    - 메서드가 호출될 때마다 메모리가 할당되어 메서드가 올라간다.
>    - 메서드가 종료되면 할당된 메모리는 반환되어 비워진다.
>    - 지역 변수가 저장되는 공간

<br>

## 클래스 메서드와 인스턴스 메서드

변수에도 클래스 (static) 변수와 인스턴스 변수가 있었던 것처럼, 메서드에도 클래스 (static) 메서드와 인스턴스 메서드가 있다.

인스턴스 변수는 인스턴스를 생성한 후에 접근 가능하지만, 클래스 (static) 변수는 인스턴스를 생성하지 않고도 접근 가능했다.

마찬가지로, 인스턴스 메서드는 인스턴스를 생성 후 호출이 가능하지만, 클래스 (static) 메서드는 인스턴스를 생성하지 않고도 호출 가능하다.

<br>

정리하자면, 인스턴스 메서드나 인스턴스 변수는 인스턴스를 생성해야 접근 가능하지만, **클래스 메서드나 클래스 변수는 클래스가 메모리에 올라갈 때 자동적으로 생성**되므로, 바로 사용할 수 있다.

따라서 인스턴스 메서드에서는 클래스 메서드나 클래스 변수를 호출, 접근 가능하다.

반대로 클래스 메서드에서는 인스턴스 메서드나 인스턴스 변수를 호출했을 때, 해당 메서드나 변수가 존재하지 않는 경우가 있을 수 있기 때문에 호출을 금지한다.

<br>

## 오버로딩

오버로딩이란, 같은 이름의 메서드를 중복하여 만들 수 있는 기능이다.

오버로딩은 다음 두 가지 조건이 충족되어야 한다.

1. 메서드의 이름이 같아야 한다.
2. 매개변수의 개수나 타입이 달라야 한다.

조건에서 볼 수 있듯이 메서드의 반환타입은 오버로딩에 연관이 없다.

<br>

## 가변인자 오버로딩

오버로딩 중 가변인자를 활용하여 오버로딩을 할 수 있는데, 아래와 같은 양식으로 사용할 수 있다.

```java
(반환타입) 메서드_이름 (타입 이름, 타입... 이름) {

}
```

<br>

## 생성자

생성자는 인스턴스를 생성할 때 호출되는 인스턴스를 초기화하는 메서드다.

생성자는 아래 두 가지 조건을 만족한다.

1. 생성자 이름은 클래스 이름과 같다.
2. 생성자는 리턴형과 리턴값이 모두 없다. (void도 없다는 뜻)

```java
class Car {
    int speed;
    int weight;
    String model;

    //생성자
    Car() {
    }
}

class carSample{
    public static void main(String args[]) {
        Car myCar = new Car();
    }
}
```

1. 연산자 new에 의해 힙 메모리에 Car 인스턴스가 생성된다.
2. 생성자 Car()가 호출되어 인스턴스가 초기화된다.
3. 생성되고 초기화된 인스턴스의 주소가 참조변수 myCar에 저장된다.

<br>

한 클래스 내에는 여러 개의 생성자가 오버로딩되어 존재할 수 있다.

각 생성자는 서로 다른 생성자를 호출할 수 있는데, 이 때 지켜야 할 조건은 다음과 같다.

1. 호출하는 생성자의 이름은 this()다.
2. 반드시 첫 줄에서만 생성자를 호출할 수 있다.

```java
class Car {
    int speed;
    int weight;
    String model;

    //생성자
    Car() {
        speed = 0;
        weight = 1200;
        model = "S3";
    }

    Car(int speed, int weight, String model) {
        this.speed = speed;
        this.weight = weight;
        this.model = model;
    }

    Car(String model) {
        this(0, 1400, model); //다른 생성자 호출
    }
}

class carSample{
    public static void main(String args[]) {
        Car myCar = new Car();
    }
}
```

<br>

## 기본 생성자

모든 클래스에는 생성자가 하나 이상 정의되어있어야한다.

**생성자가 정의되어 있지 않는 경우에는 컴파일러가 기본 생성자를 추가하여 컴파일한다.**

컴파일러가 기본 생성자를 추가하는 조건은 다음과 같다.

- 클래스에 정의된 생성자가 한 개도 없는 경우, 컴파일러가 기본 생성자를 추가하여 컴파일한다.

<br>

## 초기화 블록

초기화 블록은 변수들을 초기화하는 블록으로, 클래스 변수를 초기화하는 클래스 초기화 블록, 인스턴스 변수를 초기화하는 인스턴스 초기화 블록이 있다.

클래스 초기화 블록은 클래스가 메모리에 처음 로딩될 때 한 번만 수행된다.

인스턴스 초기화 블록은 인스턴스가 생성될 때마다 수행된다.

```java
class BlockTest {
    static { //클래스 초기화 블록
        System.out.println("STATIC BLOCK");
    }

    { //인스턴스 초기화 블록
        System.out.println("INSTANCE BLOCK");
    }

    //생성자
    BlockTest() {
        System.out.println("생성자");
    }

    public static void main(String args[]) {
        System.out.println("첫 인스턴스 생성");
        BlockTest bt1 = new BlockTest();

        System.out.println("두 번째 인스턴스 생성");
        BlockTest bt2 = new BlockTest();
    }
}
```

위 예제의 실행 결과는 아래와 같다.

```
STATIC BLOCK
첫 인스턴스 생성
INSTANCE BLOCK
생성자
두 번째 인스턴스 생성
INSTANCE BLOCK
생성자
```
